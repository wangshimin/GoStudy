## 安装环境相关
安装完毕后，命令行输入 `go env` 查看go环境变量
```shell
set GOCACHE=C:\Users\40483\AppData\Local\go-build
set GOENV=C:\Users\40483\AppData\Roaming\go\env
set GOEXE=.exe

set GOMODCACHE=C:\Users\40483\go\pkg\mod

## 工作目录、存放sdk以外的第三方类库
set GOPATH=C:\Users\40483\go

 ## 安装目录
set GOROOT=H:\Program Files\Go

## 工具目录
set GOTOOLDIR=H:\Program Files\Go\pkg\tool\windows_amd64

## 版本
set GOVERSION=go1.19.1
```

`$GOMAXPROCS` - 可使用的处理器个数与核数
`$GOPATH`可以包含多个工作目录，如果设置了多个工作目录，那么当你在之后使用 `go get`（远程包安装命令）时远程包将会被安装在第一个目录下。

Go 的 runtime （代码可在`runtime`包中找到），它负责管理包括内存分配、垃圾回收、栈处理、goroutine、channel、切片(slice)、map 和 反射（reflection）等等。 

GOPATH下需要建立3个目录：
- `bin` - 存放编译后生成的可执行文件
- `pkg` - 存放编译后生成的包文件
- `src` - 存放项目源码 

## 常用命令
- `go get` ：获取远程包
- `go run` : 直接运行程序
- `go build` ：测试编译，检查是否有编译错误
- `go fmt` ：格式化源码(部分IDE在保存时会自动调用)
- `go install` ：编译包文件并编译整个程序
- `go test` ：运行测试文件
- `go doc` ：查看文档

---
# 基础知识
	GO程序的一般结构：basic_structure.go

  - Go程序是通过 `package` 来组织的（与Python相似）
  - 只有 `package` 名称为 `main` s的包可以包含 main 函数
  - 一个可执行程序 **有且仅有** 一个 main 包  
     
  - 通过 `import` 关键字来导入其他非 main 包
  - 通过 `const` 关键字来进行常量的定义
  - 通过在函数体外使用 `var` 关键字来进行全局变量的声明与赋值
  - 通过 `func` 关键字来进行函数的声明

### 可见性规则
  - GO 语言中，使用 `大小写` 来决定该 变量、常量、类型、接口、结构 或 函数 是否可以被外部包所调用
  - 函数名首字母 `小写` 即为 `Private` ，函数名首字母 `大写` 即为 `public`

## 基本类型
数字、字符串string、布尔型、

- #### 变量
- ##### 变量的声明、赋值
	```go
	// 变量的声明格式： var <变量名称> <变量类型>
	var a int
	// 变量的赋值格式： <变量名称> = <表达式>
	a = 123
	// 变量声明的同时赋值： var <变量名称> [变量类型] = <表达式>
	var b int = 321
	// 上行的格式可省略变量类型，由系统推断
	var c = 321
	// 变量声明与赋值的最简写法
	d := 456
	``` 

	多个变量的声明与赋值
	-  全局变量的声明可使用var()的方式进行简写
	-  全局变量的声明不可以省略var，但可使用并行方式
	-  所有变量都可以使用类型推断
	-  局部变量不可以使用var()的方式简写，还能使用并行方式
	
	```go
	var (
		// 使用常规方式
		aaa = "hello"
		// 使用并行方式以及类型推断
		sss, bbb = 1, 2
		// ccc :=3 // 不可以省略var
	)
	```
- ##### 变量的类型转换
	- Go中不存在隐式转换，所有类型转换必须显示转换
	- 转换职能发生在两种相互兼容的类型之间
	- 类型转换的格式： ```<ValueA> [:]= <TypeOfValueA>(<ValueB>)```
    ```go
	// 在相互兼容的两种类型之间进行转换
	var a float32 = 1.1
	b := int(a)
	```
- #### 常量
	- 常量的值在编译时就已经确定
	- 常量的定义格式与变量基本相

	- 等号右侧必须是常量或者常量表达式
	- 常量表达式中的函数必须是内置函数

	##### 常量的初始化规则与枚举
	- 在定义常量组时，如果不提供初始值，则表示将使用上行的表达式
	- 使用相同的表达式不代表具有相同的值
	- iota是常量的计数器，从0开始，组中每定义1个常量自动递增1
	- 每遇到一个const关键字，iota就会重置为0

- #### 指针
	1. GO虽然保留了指针，但与其他编程语言不同的是，在GO当中不支持指针运算以及“ -> ”运算符，而直接采用“ . ”选择符来操作指针目标对象的成员
	2. 操作符“ & ”取变量地址，使用“ * ”通过指针间接访问目标对象
	3. 默认值为`nil`而非 NULL
	4. 在GO中，++与--是作为语句而并不是作为表达式

- #### 判断语句if
	- 条件表达式没有括号
	- 支持一个初始化表达式（可以是并行方式）
	- 左大括号必须和条件语句或else在同一行
	- 支持单行模式
	- 初始化语句中的变量为block级别，同时隐藏外部同名变量
	
- #### 循环语句for
	-	GO只有for一个循环语句关键字，但支持3种形式
	- 初始化和步进表达式可以是多个值
	- 条件语句每次循环都会被重新检查，因此不建议在条件语句中使用函数，尽量提前计算好条件并以常量或变量代替
	- 左大括号必须和条件语句在同一行

- #### 选择语句switch
	- 可以使用任何类型或表达式作为条件语句
	- 不需要写break，一旦条件符合自动终止
	- 如希望继续执行下一个case，需使用fallthrough语句
	- 支持一个初始化表达式（可以是并行方式），右侧需跟分号
	- 左大括号必须和条件语句在同一行

- #### 跳转语句 goto break continue
	- 三个语法都可以配合标签使用
	- 标签名区分大小写，若不使用会造成编译错误
	- Break与continue配合标签可用于多层循环的跳出
	- Goto是调整执行位置，与其他2个语句配合标签的结果并不相同


- #### 数组Array
	- 定义数组的格式：var <varName> [n]<type>，n>0
	- 数组长度也是类型的一部分，因此具有不同长度的数组为不同类型
	- 注意区分指向数组的指针和指针数组
	- 数组在go中为值类型
	- 数组之间可以使用 `===` 或 `!=` 进行比较，但不可以使用 `<` 或 `>`
	- 可以使用`new` 来创建数组，此方法返回一个指向数组的指针
	- Go支持多维数组
	

- #### 切片slice
	- 其本身并不是数组，它指向底层的数组
	- 作为变长数组的替代方案，可以关联底层数组的局部或全部
	- 为引用类型
	- 可以直接创建或从底层数组获取生成
	- 使用len()获取元素个数，cap()获取容量
	- 一般使用make()创建
	- 如果多个slice指向相同底层数组，其中一个的值改变会影响全部

	- make([]T, len, cap
	- 其中cap可以省略，则和len的值相同
	- len表示存数的元素个数，cap表示容量

	- Reslice
		-	Reslice时索引以被slice的切片为准
		-	索引不可以超过被slice的切片的容量cap()的值
		- 	索引越界不会导致底层数组的重新分配而是引发错误

	- Append
		-	可以在slice尾部追加元素
		-	可以将一个slice追加在另一个slice尾部
		-	如果最终长度未超过追加到slice的容量则返回原始slice
		-	如果超过追加到的slice的容量则将重新分配数组并拷贝原始数据

- #### map
	-	类似其他语言中的哈希表或者字典，以key-value形式存储数据
	- 	Key必须是支持`==`或`!=`比较运算的类型，不可以是函数、map或slice
	-	Map必须查找比线性搜索快很多，但比使用索引访问数据的类型慢100倍
	-	Map使用`make()创建`，支持:= 这种简写方式

	- 	`make([keyType]valueType, cap)`，cap表示容量，可省略
	- 	超出容量时会自动扩容，但尽量提供一个合理的初始值
	-	使用`len()`获取元素个数

	-	键值对不存在时自动添加，使用`delete()`删除某s键值对
	-	使用`for range`对map和slice进行迭代操作

- #### 函数function
	- GO函数 **不支持** 嵌套、重载和默认参数
	- 但支持以下特性：
		无需声明原型、不定长度变参、多返回值、命名返回值参数、匿名函数、闭包
	- 定义函数使用关键字 `func`，且左大括号不能另起一行
	- 函数也可以作为一种类型使用

- #### defer
	- 执行方式类似其他语言中的析构函数，在函数体执行结束后按照调用顺序的 **相反顺序** 逐个执行
	- 即使函数发生 **严重错误** 也会执行
	- 支持匿名函数的调用
	- 常用于资源清理、文件关闭、解锁以及记录时间等操作
	- 通过与匿名函数配合可在return之后修改函数计算结果
	- **如果函数体内某个变量作为defer时匿名函数的参数，则在定义defer时即已经获得了拷贝，否则则是引用某个变量的地址**
	- GO 没有异常机制，但有 panic / recover 模式来处理错误
	- Panic 可以在任何地方引发， 但 recover 只有在defer 调用的函数中有效

- #### struct
	- GO 中的struct 与 C 中的struct 非常相似，并且GO没有class
	- 使用 `type <Name> structP{}` 定义结构，名称遵循可见性规则
	- 支持指向自身的指针类型成员
	- 支持匿名结构，可用作成员或定义成员变量
	- 匿名结构也可以用于map的值
	- 可以使用字面值对结构进行初始化
	- 允许直接通过指针来读写结构成员
	- 相同类型的成员可进行直接拷贝赋值
	- 支持  `==` 与 `!=` 比较运算符，但不支持 `>` 或 `<`
	- 支持匿名字段，本质上是定义了以某个类型名为名称的字段
	- 嵌入结构作为匿名字段看起来像继承，但不是继承
	- 可以使用匿名字段指针

- #### method
	- GO 中虽没有class，但依旧有method
	- 通过显示说明receiver来实现与某个类型的组合
	- 只能为同一个包中的类型定义方法
	- Receiver可以是类型的值或者指针
	- 不存在方法重载
	- 可以使用值或指针来调用方法，编译器会自动完成转换
	- 从某种意义上来说，方法是函数的语法糖，因为receiver其实就是方法所接收的第1个参数（Method Value vs. Method Expression）
	- 如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法
	- 类型别名不会拥有底层类型所附带的方法
	- 方法可以调用结构中的非公开字段

- #### 接口 interface
	- 接口是一个或多个方法签名的集合
	- 只要某个类型拥有该接口的所有方法签名，即算实现该接口，无需显示声明实现了哪个接口，这称为Structural Typing
	- 接口只有方法声明，没有实现，没有数据字段
	- 接口可以匿名嵌入其他接口，或嵌入到结构中
	- 将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，即无法修改复制品的状态，也无法获取指针
	- 只有当接口存储的类型和对象都为nil时，接口才等于nil
	- 接口调用不会做receiver的自动转换
	- 接口同样支持匿名字段方法
	- 接口也可实现类似OOP中的多态
	- 空接口可以作为任何类型数据的容器

- #### 反射 reflection
	- 反射可大大提高程序的灵活性，使得interface{}又更大的发挥余地
	- 反射使用 `TypeOf` 和 `ValueOf` 函数从接口中获取目标对象信息
	- 反射会将匿名字段作为独立字段（匿名字段本质）
	- 想要利用反射修改对象状态，前提是 interface.data 是 settable，即 pointer-interface
	- 通过反射可以 “动态” 调用方法

- #### Channel
	- Channel 是 gouroutine 沟通的桥梁，大都是阻塞同步的
	- 通过 make 创建，close 关闭
	- Channel 是引用类型
	- 可以使用 for range 来迭代不断操作 Channel
	- 可以设置单向或双向通道
	- 可以设置缓存大小，在未被填满前不会发生阻塞

- #### Select
	- 可处理一个或多个 Channel 的发送与接收
	- 同时有多个可用的channel 时按随机顺序处理
	- 可用空的 select 来阻塞 main 函数
	- 可设置超时
	

	

	 